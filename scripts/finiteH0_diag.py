#!/usr/bin/env python3

# finiteH0_diag
# Script for analyzing hybridization functions and PDOS generated by RSPt.
# Generate a finite size non-interacting Hamiltonian, expressed in
# a spherical harmonics basis.
#
# The script performs a rotation in the end of the notebook to spherical
# harmonic basis.
# If the RSPt cluster of study uses the cubic harmonic basis,
# an explicit rotation is performed.
# Otherwise a basis defined by a projection-file is assumed.
# In this case, the rotation from this (diagonal) basis to the spherical
# harmonic basis is performed by using the eigenvectors of the
# local non-interacting Hamiltonian expressed in the spherical harmonic basis.


from math import pi
import numpy as np

from rspt2spectra import hybridization
from rspt2spectra import energies
from rspt2spectra import h2imp
from rspt2spectra import orbitals
from rspt2spectra import readfile
from rspt2spectra.constants import eV
from rspt2spectra.h2Quanty import print_QuantyH_from_dense_rsptH
# Read input parameters from local file
import rspt2spectra_parameters_diag as r2s


# Help variables
# Number of orbitals, 5 for d-system, 7 for f-system
norb = 2*int(r2s.basis_tag[3]) + 1
# Number of non-equivalent correlated spin-orbitals
nc = 2*norb if r2s.spinpol else norb
# Number of non-equivalent on-site energies
no = 2*norb if r2s.spinpol and not r2s.spinavg else norb
# Center of gravity energy windows
wmin0s = [r2s.wmin0]*no
wmax0s = [r2s.wmax0]*no
# Name of RSPt's output file.
outfile = 'out'
# Files for hybridization function
file_re_hyb = 'real-hyb-' + r2s.basis_tag + '.dat'
file_im_hyb = 'imag-hyb-' + r2s.basis_tag + '.dat'
if r2s.off_diag_hyb:
    file_re_off_hyb = 'real-offdiag-hyb-' + r2s.basis_tag + '.dat'
    file_im_off_hyb = 'imag-offdiag-hyb-' + r2s.basis_tag + '.dat'
if r2s.self_energy:
    # File for interacting PDOS
    file_pdos = 'pdos-' + r2s.basis_tag + '.dat'
    # Files for self-energies
    file_re_sig = 'real-sig-realaxis-' + r2s.basis_tag + '.dat'
    file_im_sig = 'imag-sig-realaxis-' + r2s.basis_tag + '.dat'
    file_re_off_sig = 'real-offdiag-sig-realaxis-' + r2s.basis_tag + '.dat'
    file_im_off_sig = 'imag-offdiag-sig-realaxis-' + r2s.basis_tag + '.dat'

# Diagonal hybridization functions.
w, hyb_rspt = readfile.hyb(file_re_hyb, file_im_hyb, r2s.spinpol,
                           only_diagonal_part=True)
# Plot diagonal elements of RSPt's hybridization function
if r2s.verbose_fig:
    hybridization.plot_hyb(w, hyb_rspt, r2s.xlim, r2s.spinpol)
print("Calculate hybridization strengths and bath energies")
if "eb_initial" in dir(r2s) and "wborder" not in dir(r2s):
    assert np.shape(r2s.eb_initial)[0] == nc
    vb, eb, wborder = hybridization.get_vb_and_new_eb(w, hyb_rspt.imag,
                                                      r2s.eb_initial,
                                                      accept1=0.2, accept2=0.5)
elif "wborder" in dir(r2s) and "eb_initial" not in dir(r2s):
    assert np.shape(r2s.wborder)[0] == nc
    wborder = np.copy(r2s.wborder)
    vb, eb = hybridization.get_vb_and_eb(w, hyb_rspt.imag, wborder)
else:
    sys.exit("Either the eb_initial or the wborder variable is needed...")
hyb = hybridization.hyb_d(w + 1j*r2s.eim, eb, vb)
print("eb:")
print(eb)
print("wborder:")
print(wborder)
print("vb:")
print(vb)
# Number of bath orbitals per correlated orbitals
nb = np.shape(eb)[1]
s = '{:6.3f},' * nb
print("hoppings (eV):")
for i in range(nc):
    print(str(i) + ': V_b =' + s.format(*vb[i]))
print()

# Plot discretized hybridization function
if r2s.verbose_fig:
    hybridization.plot_discrete_hyb(w, np.imag(hyb), hyb_rspt.imag, eb, vb,
                                    wborder, nc, r2s.spinpol, r2s.xlim)


# #### Calculate RSPt's non-interacting PDOS
#
# An approximation of the non-interacting PDOS is given by
# -\frac{1}{\pi} \mathrm{Im}g_{0,d}^{\mathrm{rspt}}(\omega),
#
# where
# g_{0,d}^{\mathrm{rspt}}(\omega) =
# (\omega-\epsilon_{d,d}^\mathrm{rspt}-\Delta_{d,d}^\mathrm{rspt}(\omega))^{-1}
#
# Also construct:
# g_{0,d}(\omega) =
# (\omega-\epsilon_{d,d}-\Delta_{d,d}(\omega))^{-1}
# with \epsilon_{d,d} = \epsilon_{d,d}^\mathrm{rspt}
# and
# \Delta_{d,d}(\omega)
# being the discretized hybridization function.
#
# The approximation is that off-diagonal elements of the hybridization
# function are neglected.
# This allow us to treat each spin-orbital seperatly.


# Extract the impurity energies from the local Hamiltonian
# and the chemical potential.
hs, labels = energies.parse_matrices()
mu = energies.get_mu()
for h, label in zip(hs, labels):
    # Select Hamiltonian from correct cluster
    if label == r2s.basis_tag:
        print("Extract diagonal of local H0 from cluster:", label)
        print()
        e_rspt = eV*np.real(h.diagonal() - mu)
e_rspt = e_rspt[:no]  # select non-equivalent on-site energies

# Construct the non-interacting PDOS, in three different ways.
# 1) Use RSPt hybridization function.
# 2) Use discretized hybridization function.
# 3) Use discretized hybridization function,
#    but calculated in another way.
if no == nc:
    p0d_rspt = energies.pdos(w, r2s.eim, e_rspt, hyb_rspt)
    p0d_initial = energies.pdos(w, r2s.eim, e_rspt, hyb)
    p0d_initial_alg2, eig, weight = energies.get_pdos0_eig_weight(e_rspt, eb,
                                                          vb, w, r2s.eim)
else:
    p0d_rspt = energies.pdos(w, r2s.eim, 2*list(e_rspt), hyb_rspt)
    p0d_initial = energies.pdos(w, r2s.eim, 2*list(e_rspt), hyb)
    p0d_initial_alg2, eig, weight = energies.get_pdos0_eig_weight(
        2*list(e_rspt), eb, vb, w, r2s.eim)
assert np.all(np.abs(p0d_initial - p0d_initial_alg2) < 1e-13)

# Plot non-interacting PDOS
if r2s.verbose_fig:
    energies.plot_pdos0_2(w, p0d_rspt, p0d_initial, nc, r2s.spinpol, r2s.xlim)

# Optimize $\epsilon^{(0,d)}$ so that
# $g_{0,d}(\omega) \approx g_{0,d}^{\mathrm{rspt}}(\omega)$, i.e.
# fit discretized non-interacting PDOS to the non-interacting PDOS
# by varying the on-site energies, keeping the bath parameters fixed.
# Compare PDOSes by consider the center of gravity in an energy region
# where most states are located.
#
# Start by checking how well the on-site energies from RSPt matches with the
# the discretized hybridization function.
if r2s.verbose_text:
    if nc == no:
        for i in range(no):
            tmp = energies.get_deviation(e_rspt[i], eb[i], vb[i], w, r2s.eim,
                                         p0d_rspt[i], wmin0s[i], wmax0s[i])
            print("deviation(e_rspt) =", tmp)
    else:
        for i in range(no):
                tmp = energies.get_deviation_magnetic_nonSpinPol(
                    e_rspt[i], [eb[i], eb[i + no]], [vb[i], vb[i + no]],
                    w, r2s.eim, [p0d_rspt[i], p0d_rspt[i + no]],
                    wmin0s[i], wmax0s[i])
                print("deviation(e_rspt) =", tmp)
    print()
# Calculate adjusted on-site energies
e0d = energies.get_e0(w,r2s.eim,p0d_rspt,eb,vb,nc,no,r2s.bounds,
                      wmin0s,wmax0s,r2s.verbose_text)
# non-interacting PDOS
if nc == no:
    p0d = energies.pdos(w, r2s.eim, e0d, hyb)
else:
    p0d = energies.pdos(w, r2s.eim, 2 * list(e0d), hyb)

print('e_rspt:', e_rspt, 'eV')
print('e_0d:', e0d, 'eV')
print()

# Check how well the fitting worked
if r2s.verbose_text:
    print("If the adjustment worked, the second value should be close"
          " to the first value")
    for i in range(nc):
        if i < no:
            print('<w>_p0d_rspt =', energies.cog(w, p0d_rspt[i],
                                                 wmin0s[i], wmax0s[i]))
            print('<w>_p0d =', energies.cog(w, p0d[i],
                                            wmin0s[i], wmax0s[i]))
        else:
            print('<w>_p0d_rspt =', energies.cog(w, p0d_rspt[i],
                                                 wmin0s[i - norb],
                                                 wmax0s[i - norb]))
            print('<w>_p0d =', energies.cog(w, p0d[i],wmin0s[i - norb],
                                            wmax0s[i - norb]))
        print()

# Plot non-interacting PDOS,
# using $\epsilon_\mathrm{rspt}$ and adjusted $\epsilon_{0,d}$.
if r2s.verbose_fig:
    energies.plot_pdos0_3(w, p0d_rspt, p0d_initial, p0d, nc, r2s.spinpol,
                          r2s.xlim)

# Off-diagonal hybridization functions
# Consider off-diagonal hybridization elements.
if r2s.off_diag_hyb:
    _, hybM_rspt = readfile.hyb(file_re_hyb, file_im_hyb, r2s.spinpol)
    # Calculate RSPt non-interacting PDOS,
    # using full-matrix RSPt hybridization function
    if nc == no:
        p0_rspt = np.diagonal(energies.pdos(w, r2s.eim, e_rspt, hybM_rspt)).T
    elif nc == 2*no:
        p0_rspt = np.diagonal(energies.pdos(w, r2s.eim, 2*list(e_rspt),
                                            hybM_rspt)).T

if r2s.verbose_fig and r2s.off_diag_hyb:
    # Plot off-diagonal hybridization elements
    hybridization.plot_hyb_off_diagonal(w,hybM_rspt,nc,r2s.xlim)
    # Plot non-interacting PDOSes
    energies.plot_pdos0_from_off_diagonal_hyb(w, p0d_rspt, p0_rspt, p0d,
                                              r2s.xlim)


# Repeat adjustment procedure above, but now fit to non-interacting PDOS
# calculated using off-diagonal hybridization elements.
#
# In other words, adjust $\epsilon^{(0)}$ so that
# g_{0}(\omega) \approx g_{0}^{\mathrm{rspt}}(\omega)
# where
#
# g_{0}^{\mathrm{rspt}}(\omega) = (   (\omega+i\delta)\delta_{a,b}
#                                   - \epsilon^\mathrm{rspt}_{a,a}
#                                   - \Delta^\mathrm{rspt}_{a,b}(\omega)
#                                 )^{-1}
# and
# g_{0}(\omega) = (  (\omega+i\delta)\delta_{a,b}
#                  - \epsilon_{a,a}^{(0)}
#                  - \Delta_{a,a}(\omega)
#                 )^{-1}$.
#
# Consider the center of gravity in an energy region where
# most states are located.

if r2s.off_diag_hyb:
    # Calculate adjusted on-site energies
    e0 = energies.get_e0(w, r2s.eim, p0_rspt, eb, vb, nc, no, r2s.bounds,
                         wmin0s, wmax0s, r2s.verbose_text)
    # non-interacting PDOS
    if nc == no:
        p0 = energies.pdos(w, r2s.eim, e0d, hyb)
    else:
        p0 = energies.pdos(w, r2s.eim, 2 * list(e0d), hyb)
    print("Compare on-site energies:")
    print('e_rspt:', e_rspt, 'eV')
    print('e_0d:', e0d, 'eV')
    print('e_0:', e0, 'eV')
    print()

    # Check how well the fitting worked
    if r2s.verbose_text:
        print("If the adjustment worked, the second value should be close"
              " to the first value")
        for i in range(nc):
            if i < no:
                print('<w>_p0d_rspt =', energies.cog(w, p0_rspt[i],
                                                     wmin0s[i], wmax0s[i]))
                print('<w>_p0d =', energies.cog(w, p0[i],
                                                wmin0s[i], wmax0s[i]))
            else:
                print('<w>_p0d_rspt =', energies.cog(w, p0_rspt[i],
                                                     wmin0s[i - norb],
                                                     wmax0s[i - norb]))
                print('<w>_p0d =', energies.cog(w, p0[i],wmin0s[i - norb],
                                                wmax0s[i - norb]))
            print()

    # Plot non-interacting PDOS, including off-diagonal hybridization elements
    if r2s.verbose_fig:
        energies.plot_pdos0_4(w, p0d_rspt, p0d, p0_rspt, p0, norb, r2s.spinpol,
                              r2s.xlim)


# Interacting PDOS
# Compare interacting PDOS from RSPt with the discretized version.
# Self-energy needed.
if r2s.self_energy:
    # Load interacting PDOS from file
    _, p_rspt = readfile.pdos(file_pdos, norb, r2s.spinpol)

    _, sigmaM, sigma = readfile.self_energy(file_re_sig,file_im_sig,
                                            r2s.spinpol, file_re_off_sig,
                                            file_im_off_sig)

    # Calculate RSPt PDOS in two ways:
    # - Using full-matrix RSPt hybridization function
    # - Using diagonal RSPt hybridization function
    if r2s.off_diag_hyb:
        if nc == no:
            p_rspt_alg1 = np.diagonal(energies.pdos(w, r2s.eim, e_rspt,
                                                    hybM_rspt, sigmaM)).T
            p_rspt_alg2 = np.diagonal(energies.pdos(w, r2s.eim, e_rspt,
                                                    hyb_rspt, sigmaM)).T
        elif nc == 2 * no:
            p_rspt_alg1 = np.diagonal(energies.pdos(w, r2s.eim, 2*list(e_rspt),
                                                    hybM_rspt, sigmaM)).T
            p_rspt_alg2 = np.diagonal(energies.pdos(w, r2s.eim, 2*list(e_rspt),
                                                    hyb_rspt, sigmaM)).T

    # Plot interacting PDOS
    if r2s.verbose_fig :
        energies.plot_pdos_3(w, p_rspt, p_rspt_alg1, p_rspt_alg2,
                             r2s.off_diag_hyb, r2s.spinpol)


# Repeat the adjustment of the on-site energy, as done previously.
# Adjust $\epsilon$ so that
# g(\omega) \approx g^{\mathrm{rspt}}(\omega)
# where
#
# g^{\mathrm{rspt}}(\omega) =  (  (\omega+i\delta)\delta_{a,b}
#                               - \epsilon^\mathrm{rspt}_{a,a}
#                               - \Delta^\mathrm{rspt}_{a,b}(\omega)
#                               - \Sigma_{a,b}
#                              )^{-1}$
# and
# g(\omega) =  (   (\omega+i\delta)\delta_{a,b}
#                - \epsilon_{a,a}^{(0)}
#                - \Delta_{a,a}(\omega)
#                - \Sigma_{a,b}
#              )^{-1}$.
#
# Consider the center of gravity in an energy region where
# most states are located.

if r2s.self_energy:
    # Calculate adjusted on-site energies
    e = energies.get_e(w, r2s.eim, p_rspt, hyb, sigmaM, e0, r2s.wmin, r2s.wmax,
                       r2s.verbose_text)
    # Calculate approximative PDOS
    if nc == no:
        p = np.diagonal(energies.pdos(w, r2s.eim, e, hyb, sigmaM)).T
    elif nc == 2 * no:
        p = np.diagonal(energies.pdos(w, r2s.eim, 2 * list(e), hyb, sigmaM)).T
    print
    'e_rspt:', e_rspt, 'eV'
    print
    'e_0d:', e0d, 'eV'
    if r2s.off_diag_hyb:
        print
        'e_0:', e0, 'eV'
    print
    'e:', e, 'eV'

# Plot interacting PDOS, using adjusted on-site energies $\epsilon$
if r2s.verbose_fig and r2s.self_energy:
    energies.plot_pdos_2(w, p_rspt, p, r2s.xlim)

if r2s.verbose_fig and r2s.self_energy and r2s.off_diag_hyb:
    energies.plot_pdos_5([e_rspt, e0d, e0, e], w, r2s.eim, p_rspt, hyb, sigmaM,
                         r2s.spinpol)

# Construct the non-relativistic non-interacting Hamiltonian
# in the Anderson model.
# Parameters:
# onsite-energies $\epsilon$
# bath energies $\epsilon_b
# hybridization strengths $V_b$

# Choose which algorithm to use.
if r2s.e_method == 0:
    e_onsite = e_rspt
if r2s.e_method == 1:
    e_onsite = e0d
elif r2s.e_method == 2:
    e_onsite = e0
elif r2s.e_method == 3:
    e_onsite = e

# Construct non-interacting Hamiltonian matrix
h = energies.get_h0(e_onsite, eb, vb, r2s.spinpol)

if r2s.verbose_text:
    print('Size of H: {:d}'.format(np.shape(h)[0]))
    print()
    print("Correlated orbitals:")
    print("Real part:")
    print(energies.print_matrix(h[:nc, :nc].real))
    print("Imag part:")
    print(energies.print_matrix(h[:nc, :nc].imag))
    print("First set of bath on-site energies:")
    print("Real part:")
    print(energies.print_matrix(h[2*norb:2*norb + nc,
                                  2*norb:2*norb + nc].real))
    print("Imag part:")
    print(energies.print_matrix(h[2*norb:2*norb + nc,
                                  2*norb:2*norb + nc].imag))
    print()
    print("Eigenvalues of H:")
    eigenvalues, eigenvectors = np.linalg.eigh(h)
    print(eigenvalues)

# Get unitary transformation matrix.
u = orbitals.get_u_transformation(np.shape(h)[0], r2s.basis_tag, r2s.irr_flag,
                                  r2s.spherical_bath_basis, r2s.spinpol, norb,
                                  r2s.verbose_text)
# Rotate (back) to spherical harmonics basis
print('Rotate to spherical harmonics basis.')
h_sph = np.dot(np.transpose(np.conj(u)), np.dot(h, u))

# Make sure Hamiltonian is hermitian
assert np.sum(np.abs(h_sph - np.conj(h_sph.T))) < 1e-12

if r2s.verbose_text:
    print("Dimensions of Hamiltonian:", np.shape(h_sph))
    print("Hamiltonian in spherical harmonics basis:")
    print("Correlated block:")
    print("Real part:")
    print(energies.print_matrix(np.real(h_sph[:2*norb, :2*norb])))
    print('Imag part:')
    print(energies.print_matrix(np.imag(h_sph[:2*norb, :2*norb])))
    print()
    print("First bath set:")
    print("Real part:")
    print(energies.print_matrix(np.real(h_sph[2*norb:4*norb, 2*norb:4*norb])))
    print("Imag part:")
    print(energies.print_matrix(np.imag(h_sph[2*norb:4*norb, 2*norb:4*norb])))
    print()
    print("Hopping to first bath set:")
    print("Real part:")
    print(energies.print_matrix(np.real(h_sph[2*norb:4*norb, :2*norb])))
    print("Imag part:")
    print(energies.print_matrix(np.imag(h_sph[2*norb:4*norb, :2*norb])))
    print()
    print("Number of non-zero elements in H:",len(np.flatnonzero(h_sph)))

if r2s.save2Quanty:
    print_QuantyH_from_dense_rsptH(h_sph, ang=(norb-1)//2, previous_orbitals=6)

hOperator = h2imp.get_H_operator_from_dense_rspt_H_matrix(h_sph,
                                                          ang=(norb-1)//2)
if r2s.verbose_text:
    print("Hamiltonian operator:")
    print(hOperator)
    #repr(hOperator)
    print()
    assert (np.shape(h_sph)[0] - 2*norb) % (2*norb) == 0
    print('{:d} bath states per impurity spin-orbital.'.format(
        (np.shape(h_sph)[0] - 2*norb)//(2*norb)))
    print('{:d} bath states in total.'.format(np.shape(h_sph)[0] - 2*norb))
h2imp.write_to_file(hOperator, r2s.output_filename)
